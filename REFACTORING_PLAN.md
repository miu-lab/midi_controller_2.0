# Plan de Refactoring et d'Am√©lioration - Contr√¥leur MIDI

## Vue d'ensemble

Ce document d√©taille le plan complet de refactoring et d'am√©lioration du projet de contr√¥leur MIDI. Le projet suit une architecture hexagonale avec injection de d√©pendances et vise √† optimiser les performances pour les syst√®mes embarqu√©s tout en maintenant une architecture propre et maintenable.

## √âtat Actuel du Projet

### Architecture Existante
- **Architecture Hexagonale** bien impl√©ment√©e avec s√©paration Core/Adapters/App
- **Injection de D√©pendances** moderne via `DependencyContainer`
- **Gestion d'√©v√©nements** unifi√©e avec `EventBus`
- **Configuration unifi√©e** via `ControlDefinition`
- **Tests unitaires** supprim√©s pour faciliter le refactoring agile

### Points Forts Identifi√©s
- S√©paration claire des responsabilit√©s
- Patterns architecturaux coh√©rents
- Code bien document√©
- Coverage de tests √©lev√©

### Probl√®mes Identifi√©s
- Incoh√©rences dans l'usage des smart pointers
- Patterns dangereux avec des singletons
- Usage intensif de STL non optimis√© pour l'embarqu√©
- Allocation dynamique dans les chemins critiques MIDI
- Fragmentation m√©moire potentielle

---

## PHASE 1 : STANDARDISATION DES PATTERNS ‚úÖ TERMIN√âE

### 1.1 Unification de la Gestion d'Erreurs ‚úÖ TERMIN√â

**Objectif** : Standardiser sur la structure `Error` et √©liminer les incoh√©rences

#### √âtapes R√©alis√©es :
1. **Analyse des incoh√©rences** ‚úÖ
   - Identification de `Result<T, std::string>` dans `ErrorUtils.hpp`
   - Recensement des patterns `Error(ErrorCode, message)` vs `{ErrorCode, message}`
   - Audit complet de l'usage des types d'erreur

2. **Correction d'ErrorUtils.hpp** ‚úÖ
   - Remplacement de `Result<T, std::string>` par `Result<T>`
   - Ajout d'une surcharge pour `printError(const Error&, const char*)`
   - Am√©lioration de l'affichage des codes d'erreur

3. **Standardisation des patterns de cr√©ation** ‚úÖ
   - `UISystemCore.cpp` : Uniformisation vers `{ErrorCode, message}`
   - `UISubsystem.cpp` : Standardisation des patterns
   - `InputSubsystem.cpp` : Correction de 8 occurrences
   - `InputManager.cpp` : Standardisation du pattern

#### R√©sultats :
- ‚úÖ Compilation r√©ussie
- ‚úÖ Coh√©rence compl√®te dans la gestion d'erreurs

### 1.2 Standardisation des Smart Pointers ‚úÖ TERMIN√â

**Objectif** : Clarifier l'ownership et optimiser les performances m√©moire

#### √âtapes R√©alis√©es :

1. **Correction des patterns dangereux de singleton** ‚úÖ
   - **EventBus.hpp** : Ajout de `getSharedInstance()` s√©curis√©e
   - **InitializationScript.cpp** : Remplacement du pattern dangereux
   - **EventManager.cpp** : Usage de la nouvelle m√©thode
   - **R√©sultat** : √âlimination des custom deleters vides dangereux

2. **Gestion de ApplicationConfiguration** ‚úÖ
   - **Probl√®me** : Tentative de copie d'une classe non-copiable
   - **Solution** : Maintien du pattern wrapper avec documentation claire
   - **Justification** : Cycle de vie garanti par le caller

3. **Uniformisation dans InputManager** ‚úÖ
   - **Changements** :
     ```cpp
     // Avant
     std::shared_ptr<EncoderManager> encoderManager_;
     std::shared_ptr<DigitalButtonManager> buttonManager_;
     
     // Apr√®s
     std::unique_ptr<EncoderManager> encoderManager_;
     std::unique_ptr<DigitalButtonManager> buttonManager_;
     ```
   - **M√©thodes getter** : Retour de raw pointers au lieu de shared_ptr
   - **Cr√©ation** : `make_unique` au lieu de `make_shared`

#### R√©sultats :
- ‚úÖ R√©duction de l'overhead m√©moire des smart pointers
- ‚úÖ Clarification de l'ownership (unique vs partag√©)
- ‚úÖ Compilation r√©ussie
- ‚úÖ Patterns d'ownership coh√©rents et optimis√©s

### 1.3 √âlimination RTTI ‚úÖ TERMIN√â

**Objectif** : Purger compl√®tement l'usage de RTTI pour optimiser les performances

#### √âtapes R√©alis√©es :
1. **Audit complet RTTI** ‚úÖ
   - ‚úÖ Recherche compl√®te des usages de `typeid()`, `std::type_index`, `dynamic_cast`
   - ‚úÖ Identification de `<typeindex>` inutile dans `DependencyContainer.hpp`
   - ‚úÖ V√©rification que `TypeIdGenerator` remplace correctement `typeid()`

2. **Nettoyage final** ‚úÖ
   - ‚úÖ Suppression de `#include <typeindex>` inutile
   - ‚úÖ V√©rification que `std::static_pointer_cast` (acceptable) est utilis√©
   - ‚úÖ Pas de `dynamic_cast` trouv√© dans le codebase

3. **Validation** ‚úÖ
   - ‚úÖ Compilation r√©ussie sans headers RTTI
   - ‚úÖ `TypeIdGenerator` fonctionne correctement
   - ‚úÖ Code pr√™t pour compilation avec `-fno-rtti` si n√©cessaire

#### R√©sultats :
- ‚úÖ RTTI compl√®tement √©limin√© du codebase
- ‚úÖ Compilation r√©ussie et optimis√©e
- ‚úÖ Architecture pr√™te pour syst√®mes embarqu√©s stricts

### 1.4 Migration EventBus vers Injection de D√©pendance ‚úÖ TERMIN√â

**Objectif** : Migrer EventBus du pattern singleton vers l'injection de d√©pendance pour plus de coh√©rence et maintenabilit√©

#### Avantages de la Migration :
- **Coh√©rence architecturale** : Alignement avec le pattern DI utilis√© partout ailleurs
- **Testabilit√©** : Possibilit√© d'injecter des mock EventBus
- **Flexibilit√©** : Diff√©rentes impl√©mentations selon le contexte
- **D√©couplage** : √âlimination des d√©pendances singleton cach√©es
- **Cycle de vie ma√Ætris√©** : EventBus g√©r√© par le DI container

#### √âtapes R√©alis√©es :
1. **Cr√©ation de l'interface IEventBus** ‚úÖ
   - ‚úÖ D√©finir l'interface abstraite pour le bus d'√©v√©nements
   - ‚úÖ Extraire les m√©thodes essentielles d'EventBus
   - ‚úÖ Namespace coh√©rent avec l'architecture (MidiController::Events::IEventBus)

2. **Refactorisation d'EventBus** ‚úÖ
   - ‚úÖ Transformer EventBus en impl√©mentation : public IEventBus
   - ‚úÖ Supprimer le pattern singleton
   - ‚úÖ Conserver toute la logique m√©tier actuelle
   - ‚úÖ Ajout des annotations `override` sur toutes les m√©thodes

3. **Mise √† jour du DI Container** ‚úÖ
   - ‚úÖ Enregistrement d'EventBus dans InitializationScript
   - ‚úÖ Interface IEventBus disponible pour injection
   - ‚úÖ Suppression des acc√®s `getInstance()`

4. **Migration des consommateurs** ‚úÖ
   - ‚úÖ ViewManagerEventListener: injection d'IEventBus via constructeur
   - ‚úÖ MidiOutputEventAdapter: injection d'IEventBus pour publication
   - ‚úÖ EventBatcher: injection d'IEventBus pour abonnement/publication
   - ‚úÖ EventManager: injection d'IEventBus via constructeur
   - ‚úÖ UISubsystem et MidiSubsystem: r√©solution depuis le container
   - ‚úÖ Tests de compilation r√©ussis

#### R√©sultats :
- ‚úÖ Compilation r√©ussie
- ‚úÖ √âlimination compl√®te du pattern singleton pour EventBus
- ‚úÖ Architecture coh√©rente avec injection de d√©pendance
- ‚úÖ Pr√™t pour l'int√©gration de mocks et tests

### 1.5 Consolidation EventBus/EventManager üîÑ EN COURS

**Objectif** : Unifier l'API d'√©v√©nements et √©liminer la confusion entre EventBus et EventManager

#### Analyse des Conflits :
- **EventBus** : Bus d'√©v√©nements singleton avec priorit√©s
- **EventManager** : Gestionnaire avec batching et configuration
- **Probl√®me** : Coexistence cr√©ant de la confusion

#### Plan d'Action :
1. **Audit de l'usage** üî≤
   - [ ] Identifier tous les usages d'EventBus vs EventManager
   - [ ] Cartographier les fonctionnalit√©s sp√©cifiques √† chaque classe
   - [ ] D√©terminer les d√©pendances crois√©es

2. **Conception de l'API unifi√©e** üî≤
   - [ ] D√©finir l'interface unifi√©e
   - [ ] Int√©grer le batching dans EventBus
   - [ ] Pr√©server les fonctionnalit√©s de priorit√©

3. **Migration** üî≤
   - [ ] Refactoriser le code client
   - [ ] Mettre √† jour les tests
   - [ ] Supprimer EventManager redondant

---

## PHASE 2 : OPTIMISATIONS PERFORMANCE üî≤ √Ä FAIRE

### 2.1 Remplacement STL par ETL dans les Chemins Critiques

**Objectif** : √âliminer les allocations dynamiques dans les chemins temps r√©el

#### Probl√®mes Identifi√©s :
1. **MidiInHandler.cpp** :
   ```cpp
   std::vector<CcCallback> ccCallbacks_;           // Allocation dynamique
   std::vector<NoteCallback> noteOnCallbacks_;     // lors d'ajouts
   std::vector<NoteCallback> noteOffCallbacks_;
   ```

2. **EventBatcher.cpp** :
   ```cpp
   std::map<uint16_t, PendingParameter> pending_parameters_; // O(log n) lookup
   ```

3. **DependencyContainer.hpp** :
   ```cpp
   std::unordered_map<const void*, std::shared_ptr<void>> dependencies_; // Fragmentation
   ```

#### Plan d'Action :
1. **Installation d'ETL** üî≤
   - [ ] Ajouter ETL comme d√©pendance dans `platformio.ini`
   - [ ] Configurer les limites de taille appropri√©es
   - [ ] Cr√©er des wrappers de compatibilit√© si n√©cessaire

2. **Remplacement des containers critiques** üî≤
   - [ ] **MidiInHandler** : `etl::vector<CcCallback, MAX_MIDI_CALLBACKS>`
   - [ ] **EventBatcher** : `etl::flat_map<uint16_t, PendingParameter, 128>`
   - [ ] **EventBus** : `etl::vector<Subscription, MAX_SUBSCRIBERS>`

3. **Configuration des tailles maximales** üî≤
   ```cpp
   // Constantes √† d√©finir dans config/PerformanceConfig.hpp
   static constexpr size_t MAX_MIDI_CALLBACKS = 32;
   static constexpr size_t MAX_SUBSCRIBERS = 24;
   static constexpr size_t MAX_PENDING_PARAMS = 128;
   ```

4. **Tests et validation** üî≤
   - [ ] Tests unitaires avec containers ETL
   - [ ] Tests de performance vs STL
   - [ ] Mesure de l'usage m√©moire

### 2.2 Impl√©mentation d'Object Pools

**Objectif** : R√©duire la fragmentation m√©moire avec des pools d'objets

#### Conception des Pools :
1. **EventPool** üî≤
   ```cpp
   template<typename T, size_t N>
   class ObjectPool {
       alignas(T) char storage_[N * sizeof(T)];
       std::bitset<N> used_;
       
   public:
       T* acquire();
       void release(T* obj);
       size_t available() const;
   };
   ```

2. **Pools sp√©cifiques** üî≤
   - [ ] **MidiEventPool** : Pour les √©v√©nements MIDI haute fr√©quence
   - [ ] **UIEventPool** : Pour les √©v√©nements d'interface
   - [ ] **ParameterEventPool** : Pour les changements de param√®tres

#### √âtapes d'Impl√©mentation :
1. **Impl√©mentation du template de base** üî≤
   - [ ] Template `ObjectPool<T, N>` g√©n√©rique
   - [ ] Gestion RAII avec destructeurs automatiques
   - [ ] Thread-safety pour l'embarqu√© (sans std::mutex)

2. **Int√©gration dans le syst√®me d'√©v√©nements** üî≤
   - [ ] Modification d'EventBus pour utiliser les pools
   - [ ] Factory methods pour cr√©er des √©v√©nements depuis les pools
   - [ ] RAII guards pour lib√©ration automatique

3. **Monitoring et diagnostics** üî≤
   - [ ] Compteurs d'utilisation des pools
   - [ ] D√©tection de fuites d'objets
   - [ ] M√©triques de performance

### 2.3 Optimisation des Allocations MIDI

**Objectif** : Atteindre une latence MIDI < 1ms avec z√©ro allocation

#### Probl√®mes Sp√©cifiques :
1. **Callbacks MIDI dynamiques** : Allocation lors de l'ajout
2. **Event batching** : `std::map` avec allocations
3. **Message queuing** : Buffers dynamiques

#### Solutions Propos√©es :
1. **Callbacks statiques** üî≤
   ```cpp
   class StaticMidiHandler {
       CcCallback callbacks_[MAX_CC_CALLBACKS];
       size_t callback_count_;
       
   public:
       bool addCallback(CcCallback callback);
       void removeCallback(size_t index);
   };
   ```

2. **Ring buffers pour les messages** üî≤
   ```cpp
   template<typename T, size_t N>
   class RingBuffer {
       T buffer_[N];
       volatile size_t read_pos_;
       volatile size_t write_pos_;
   };
   ```

3. **Batching optimis√©** üî≤
   ```cpp
   struct MidiEventBatch {
       PendingParameter params[128]; // Index par CC number
       uint8_t param_count;
       uint32_t timestamp;
   };
   ```

---

## PHASE 3 : RESTRUCTURATION MODULAIRE üî≤ √Ä FAIRE

### 3.1 Extraction des Services M√©tier

**Objectif** : S√©parer la logique m√©tier pure des d√©tails d'impl√©mentation

#### Services √† Extraire :
1. **ValidationService** üî≤
   ```cpp
   namespace MidiController::Services {
       class IValidationService {
       public:
           virtual Result<void> validateControlDefinition(const ControlDefinition&) = 0;
           virtual Result<void> validateMidiMapping(const MidiMapping&) = 0;
           virtual Result<void> validateNavigationAction(const NavigationAction&) = 0;
       };
   }
   ```

2. **ConfigurationService** üî≤
   - [ ] Extraction de la logique de validation complexe
   - [ ] Service de transformation de configuration
   - [ ] Gestion des profils et pr√©sets

3. **NavigationService** üî≤
   - [ ] Logique de navigation pure
   - [ ] Mapping des actions de navigation
   - [ ] √âtat de navigation global

#### Plan d'Extraction :
1. **D√©finition des interfaces** üî≤
   - [ ] `IValidationService` : Validation cross-cutting
   - [ ] `IConfigurationService` : Gestion configuration
   - [ ] `INavigationService` : Service navigation d√©di√©

2. **Impl√©mentation des services** üî≤
   - [ ] Services concrets avec logique m√©tier pure
   - [ ] Tests unitaires pour chaque service
   - [ ] Integration dans le DI container

3. **Migration des subsystems** üî≤
   - [ ] Injection des services dans les subsystems
   - [ ] Suppression de la logique dupliqu√©e
   - [ ] Tests d'int√©gration

### 3.2 S√©paration des Responsabilit√©s des Subsystems

**Objectif** : Appliquer strictement le principe de responsabilit√© unique

#### Probl√®mes Actuels :
1. **ConfigurationSubsystem** : Config + Navigation + Validation
2. **InputSubsystem** : Hardware + Navigation + Validation  
3. **UISubsystem** : Display + Events + Validation
4. **MidiSubsystem** : MIDI + Mappings + Commands

#### Nouveau Design :
1. **ConfigurationSubsystem** (responsabilit√© unique) üî≤
   ```cpp
   class ConfigurationSubsystem : public IConfiguration {
   private:
       std::shared_ptr<Services::IValidationService> validator_;
       std::shared_ptr<Infrastructure::IStoragePort> storage_;
   public:
       Result<std::vector<ControlDefinition>> loadControlDefinitions() override;
       Result<void> saveControlDefinitions(const std::vector<ControlDefinition>&) override;
   };
   ```

2. **NavigationSubsystem** (nouveau) üî≤
   ```cpp
   class NavigationSubsystem : public INavigationService {
   private:
       std::shared_ptr<Events::IEventBus> eventBus_;
       std::shared_ptr<IConfiguration> config_;
       std::unordered_map<InputId, NavigationAction> mappings_;
   public:
       Result<void> processNavigationInput(InputId, const InputEvent&) override;
       Result<void> registerNavigationAction(InputId, const NavigationAction&) override;
   };
   ```

### 3.3 R√©organisation des Adapters

**Objectif** : Structurer les adapters par domaine fonctionnel

#### Structure Actuelle :
```
src/adapters/
‚îú‚îÄ‚îÄ primary/ui/...         (m√©lange de responsabilit√©s)
‚îú‚îÄ‚îÄ secondary/hardware/... (structure plate)
```

#### Nouvelle Structure Propos√©e :
```
src/adapters/
‚îú‚îÄ‚îÄ hardware/              # Adapters hardware purs
‚îÇ   ‚îú‚îÄ‚îÄ input/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ TeensyInputAdapter.hpp
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ MockInputAdapter.hpp
‚îÇ   ‚îî‚îÄ‚îÄ display/
‚îÇ       ‚îú‚îÄ‚îÄ ILI9341Adapter.hpp
‚îÇ       ‚îî‚îÄ‚îÄ MockDisplayAdapter.hpp
‚îú‚îÄ‚îÄ software/              # Adapters software
‚îÇ   ‚îú‚îÄ‚îÄ midi/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ UsbMidiAdapter.hpp
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ SerialMidiAdapter.hpp
‚îÇ   ‚îî‚îÄ‚îÄ storage/
‚îÇ       ‚îú‚îÄ‚îÄ FlashStorageAdapter.hpp
‚îÇ       ‚îî‚îÄ‚îÄ MemoryStorageAdapter.hpp
‚îî‚îÄ‚îÄ ui/                    # Adapters UI
    ‚îú‚îÄ‚îÄ lvgl/
    ‚îÇ   ‚îú‚îÄ‚îÄ LvglUIAdapter.hpp
    ‚îÇ   ‚îî‚îÄ‚îÄ LvglThemeAdapter.hpp
    ‚îî‚îÄ‚îÄ console/
        ‚îî‚îÄ‚îÄ ConsoleUIAdapter.hpp
```

#### Plan de R√©organisation :
1. **Analyse des d√©pendances** üî≤
   - [ ] Cartographie des d√©pendances actuelles
   - [ ] Identification des modules √† d√©placer
   - [ ] Plan de migration sans casser les builds

2. **Cr√©ation de la nouvelle structure** üî≤
   - [ ] Nouveaux dossiers et namespaces
   - [ ] Factory pattern pour les adapters
   - [ ] Interfaces unifi√©es par domaine

3. **Migration progressive** üî≤
   - [ ] Migration par domaine (hardware ‚Üí software ‚Üí ui)
   - [ ] Tests de non-r√©gression √† chaque √©tape
   - [ ] Mise √† jour des includes et d√©pendances

---

## PHASE 4 : TESTS ET VALIDATION üî≤ √Ä FAIRE

### 4.1 Strat√©gie de Tests Revisit√©e

**D√©cision** : Tests unitaires supprim√©s pour faciliter le refactoring agile

#### Nouvelle Approche :
1. **Tests supprim√©s** ‚úÖ TERMIN√â
   - ‚úÖ Suppression compl√®te du dossier `test/`
   - ‚úÖ Nettoyage de `platformio.ini`
   - ‚úÖ Compilation valid√©e sans d√©pendances de test

2. **Tests futurs** üî≤ (Post-refactoring)
   - [ ] R√©impl√©mentation from scratch apr√®s stabilisation
   - [ ] Focus sur tests d'int√©gration plut√¥t qu'unitaires
   - [ ] Tests de performance en priorit√©

3. **Validation actuelle** ‚úÖ
   - ‚úÖ Tests de compilation √† chaque √©tape
   - ‚úÖ Validation manuelle des fonctionnalit√©s critiques

### 4.2 Tests de Performance et Validation

**Objectif** : Valider les gains de performance et la stabilit√©

#### M√©triques Cibles :
1. **Performance MIDI** üî≤
   - [ ] Latence < 1ms (vs 2-5ms actuellement)
   - [ ] Jitter < 100Œºs
   - [ ] Z√©ro allocation dans les chemins critiques

2. **Utilisation M√©moire** üî≤
   - [ ] Fragmentation < 5% (vs 15-25% actuellement)
   - [ ] Utilisation CPU < 50% (vs 60-80% actuellement)
   - [ ] Stack usage pr√©visible et born√©

3. **Stabilit√©** üî≤
   - [ ] Tests de stress 24h+ sans fuite m√©moire
   - [ ] Tests de robustesse avec charges MIDI √©lev√©es
   - [ ] Validation du comportement temps r√©el

#### Infrastructure de Test :
1. **Profiling embarqu√©** üî≤
   ```cpp
   class EmbeddedProfiler {
       struct Metrics {
           uint32_t cycle_count;
           uint32_t max_latency_us;
           uint32_t avg_latency_us;
           uint32_t memory_usage;
       };
   public:
       void startProfiling(const char* section);
       void endProfiling();
       Metrics getMetrics() const;
   };
   ```

2. **Tests automatis√©s** üî≤
   - [ ] Continuous Integration avec mesures de performance
   - [ ] Tests de r√©gression automatiques
   - [ ] Alertes sur d√©gradation de performance

---

## M√âTRIQUES DE SUCC√àS

### Performances Cibles
| M√©trique | Avant | Cible | Status |
|----------|--------|--------|---------|
| Latence MIDI | 2-5ms | <1ms | üî≤ √Ä mesurer |
| Utilisation CPU | 60-80% | 30-50% | üî≤ √Ä mesurer |
| Fragmentation heap | 15-25% | <5% | üî≤ √Ä mesurer |
| Taille binaire | ~245KB | ~200KB | üî≤ √Ä mesurer |

### Qualit√© Code
| Aspect | Status |
|--------|--------|
| Error handling unifi√© | ‚úÖ Termin√© |
| Smart pointers coh√©rents | ‚úÖ Termin√© |
| RTTI √©limin√© | üîÑ En cours |
| Compilation sans erreurs | ‚úÖ Valid√© |

---

## PLANNING ESTIM√â

### Phase 1 (Standardisation) : ‚úÖ 3 jours - TERMIN√â
- ‚úÖ Error handling : 0.5 jour
- ‚úÖ Smart pointers : 1 jour  
- üîÑ RTTI : 0.5 jour (en cours)
- üî≤ EventBus/EventManager : 1 jour

### Phase 2 (Performance) : üî≤ 4 jours - √Ä FAIRE
- üî≤ ETL migration : 2 jours
- üî≤ Object Pools : 1 jour
- üî≤ MIDI optimizations : 1 jour

### Phase 3 (Restructuration) : üî≤ 5 jours - √Ä FAIRE
- üî≤ Services m√©tier : 2 jours
- üî≤ Subsystems refactor : 2 jours
- üî≤ Adapters reorganization : 1 jour

### Phase 4 (Validation) : üî≤ 1 jour - √Ä FAIRE
- üî≤ Performance validation : 1 jour
- üî≤ Tests d'int√©gration manuels : Int√©gr√© dans autres phases

**Total estim√© : 12 jours** *(r√©vis√© √† la baisse)*
**Progression actuelle : ~30% (3.5/12 jours)**

---

## NOTES TECHNIQUES

### Compatibilit√©
- ‚úÖ Teensy 4.1 : Support maintenu
- ‚úÖ C++20 : Standard respect√©
- ‚úÖ Arduino Framework : Compatibilit√© pr√©serv√©e
- ‚úÖ LVGL 9.3.0 : Int√©gration maintenue

### Risques Identifi√©s
1. **ETL Learning Curve** : Adaptation de l'√©quipe aux nouveaux containers
2. **Memory Constraints** : Validation sur hardware r√©el n√©cessaire
3. **Breaking Changes** : Migration progressive pour minimiser les risques

### Prochaines √âtapes Imm√©diates
1. üîÑ Terminer l'√©limination RTTI
2. üî≤ Consolider EventBus/EventManager  
3. üî≤ Installer et configurer ETL
4. üî≤ Commencer la migration des containers critiques

---

*Document mis √† jour le : $(date)*
*Version : 1.0*
*Statut : Phase 1 en cours (75% termin√©e)*